<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,">










<meta name="description" content="排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图 排序分为内部排序和外部排序，内部排序是排序过程中所有数据是放入内存进行处理的，外部排序是排序期间全部对象个数太多，不能同时放入你内存进行处理，需要不断在内外存进行移动的序列，下面讨论的是内部排序。 插入排序 插入排序的丝线格式将对象插入到前面已经排好序的子序列中。直到全部对象插入完成为止。 直接插入排序是初始化两个数组，一个数组">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="各种排序的比较">
<meta property="og:url" content="http://yoursite.com/2018/03/24/2018-03-24-各种排序的比较/index.html">
<meta property="og:site_name" content="Labradors">
<meta property="og:description" content="排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图 排序分为内部排序和外部排序，内部排序是排序过程中所有数据是放入内存进行处理的，外部排序是排序期间全部对象个数太多，不能同时放入你内存进行处理，需要不断在内外存进行移动的序列，下面讨论的是内部排序。 插入排序 插入排序的丝线格式将对象插入到前面已经排好序的子序列中。直到全部对象插入完成为止。 直接插入排序是初始化两个数组，一个数组">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i.imgur.com/UKBTzhi.png">
<meta property="og:image" content="http://i.imgur.com/eKhLwYY.gif">
<meta property="og:image" content="http://i.imgur.com/2359MmU.gif">
<meta property="og:image" content="http://i.imgur.com/DPS5nEw.gif">
<meta property="og:image" content="http://i.imgur.com/NtL9KyM.gif">
<meta property="og:image" content="http://i.imgur.com/f10zveN.gif">
<meta property="og:image" content="http://i.imgur.com/T0tW5Ev.gif">
<meta property="og:image" content="http://i.imgur.com/IdjmrEz.gif">
<meta property="og:updated_time" content="2018-11-13T12:01:18.448Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="各种排序的比较">
<meta name="twitter:description" content="排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图 排序分为内部排序和外部排序，内部排序是排序过程中所有数据是放入内存进行处理的，外部排序是排序期间全部对象个数太多，不能同时放入你内存进行处理，需要不断在内外存进行移动的序列，下面讨论的是内部排序。 插入排序 插入排序的丝线格式将对象插入到前面已经排好序的子序列中。直到全部对象插入完成为止。 直接插入排序是初始化两个数组，一个数组">
<meta name="twitter:image" content="http://i.imgur.com/UKBTzhi.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/24/2018-03-24-各种排序的比较/">





  <title>各种排序的比较 | Labradors</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Labradors</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Follow your heart</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/2018-03-24-各种排序的比较/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Labradors">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Labradors">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">各种排序的比较</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T22:56:00+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图"><a href="#排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图" class="headerlink" title="排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图"></a>排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图</h2><p><img src="http://i.imgur.com/UKBTzhi.png" alt="排序的类型和方法"></p>
<p>排序分为内部排序和外部排序，内部排序是排序过程中所有数据是放入内存进行处理的，外部排序是排序期间全部对象个数太多，不能同时放入你内存进行处理，需要不断在内外存进行移动的序列，下面讨论的是内部排序。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="http://i.imgur.com/eKhLwYY.gif" alt=""></p>
<p>插入排序的丝线格式将对象插入到前面已经排好序的子序列中。直到全部对象插入完成为止。</p>
<p><strong>直接插入排序</strong>是初始化两个数组，一个数组的元素为原始序列，一个数组的元素为null ，引用arr[0]作为监视哨。直接插入排序是一种稳定的排序算法，时间复杂度为O(n^2)</p>
<pre><code>public class InsertSort {

    public static void main(String []args){
        int []arr={1,45,767,879,45,788,443 ,545,4,6,7,85};
        int i,j;
        for(i=2;i&lt;arr.length;i++){
            arr[0]=arr[i];
            j=i-1;
            while (arr[0]&lt;arr[j]) {
                arr[j+1]=arr[j];
                        j--;

            }
            arr[j+1]=arr[0];
        }
        for (int j2 = 1; j2 &lt; arr.length; j2++) {
            System.out.print(arr[j2]+&quot; &quot;);
        }

    }
}
</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="http://i.imgur.com/2359MmU.gif" alt=""></p>
<p>希尔排序又称为缩小增量排序，它是一种对直接插入排序的改进，将整个子序列分成若干子序列分别进行直接插入排序。待整个序列基本有序后再对全部序列进行一次直接插入排序。</p>
<p>public class ShellSort {</p>
<pre><code>public static void  main(String []args) {
    int  []arr={1,23,435,657,87,5,5,768,4453,778,32};
    int i,j,d ,n=arr.length;
    for ( d = n/2; d &gt;0; d=d/2) {
        for ( i = d+1; i &lt;=n; i++) {
            arr[0] = arr[i];
            j=i-d;
            while (j&gt;=0&amp;&amp;arr[0]&lt;arr[j]) 
                arr[j+d]=arr[j];
                j=j-d;
                arr[j+d]=arr[0];
        }
    }

for (int k = 1; k &lt; arr.length-1; k++) {
    System.out.print(arr[k]+&quot; &quot;);
}
</code></pre><p>}<br>}</p>
<p>##交换排序<br><strong>冒泡排序</strong></p>
<p><img src="http://i.imgur.com/DPS5nEw.gif" alt=""></p>
<p>冒泡排序是一种最直观的排序方法，排序过程中，将相邻的元素进行比较，若前面的元素大于后面的元素，则将他们进行交换。冒泡排序是一种稳定的排序算法。时间复杂度为O(n^2).</p>
<pre><code>public void sort(char arr[]){
int exchange=0;  
char temp=&apos;a&apos;;  
for(int c=0;c&lt;length;c++) 
 {  
for(int ch=0; ch&lt;arr.length()-1;ch++){  
   if(arr[ch]&gt;arr[ch+1]){  
   temp=arr[ch];  
   arr[ch]=arr[ch+1];  
   arr[ch+1]=temp;  
   exchange=1;  
}  
}  
if(exchange==0) break;  
}  
for (int d = 0; d &lt; arr.length(); d++)
     {  
   System.out.print(arr[d]);  
 }  
}
</code></pre><p><strong>快速排序</strong></p>
<p><img src="http://i.imgur.com/NtL9KyM.gif" alt=""></p>
<p>快速排序是对冒泡排序的一种改进，，在冒泡排序中，数据的移动是在相邻的两个元素之间，所以造成了移动次数较多。快速排序是从两端向中间进行的。其基本做法是选择排序中的一个元素为基准，一般选取第一个元素。通过一趟排序将带排序的记录分为左右两个子序列。左边的所有元素均小于或等于关键字，右边的所有元素均大于或等于关键字。</p>
<pre><code>public class QuickSort {
    static int []arr={1,223,65,44,2,5,3,64,2,5};
    static int high = arr.length;
    public static int Partition(int arr[],int low,int high){
        arr[0] = arr[low];
        while (low&lt;high) {
            while (low&lt;high&amp;&amp;arr[high]&gt;=arr[0])
                --high;
                arr[low]=arr[high];
            while (low&lt;high&amp;&amp;arr[low]&lt;=arr[0])
                arr[high]=arr[low];

        }
        arr[low]=arr[0];
        return low;

    }
    public static void Quicksort(int arr[],int low,int high){
        int loc;
        if(low&lt;high){
            loc = Partition(arr,low,high);
            Quicksort(arr, low, loc-1);
            Quicksort(arr, loc+1, high);
    }
    }
    public static void main(String []args) {
        Quicksort(arr, 0, high);
        for (int i = 0; i &lt; args.length; i++) {
            System.out.print(arr[i]);
        }

        }
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>简单选择排序</strong></p>
<p><img src="http://i.imgur.com/f10zveN.gif" alt=""></p>
<p>简单选择排序也称直接选择排序，它先选出关键字最小的元素放在第一个位置，然后选出关键字第二小的元素放在第二个位置，依次….简单选择排序是一种不稳定的算法，时间复杂度为O(n^2)</p>
<pre><code>public class SelectSort {

    public static void  main(String []args) {
        int []arr = {1,3234,6788,7,66,89,57,5,6,95,3,6};
        int n = arr.length-1;
        int i,j,min;
        for ( i = 1; i &lt; n; i++) 
        {
            min = i;
            for ( j = i+1; j &lt;=n; ++j) 
                if (arr[min]&gt;arr[j]) 
                    min= j;
                if(min!=i)
                {
                    arr[0]=arr[min];
                    arr[min]=arr[i];
                    arr[i]=arr[0];
                }
            }
        for (int k = 1; k &lt; arr.length; k++) {
            System.out.print(arr[k]+&quot; &quot;);
        }
    }
}
</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="http://i.imgur.com/T0tW5Ev.gif" alt=""></p>
<pre><code>public class HeapSort {
private static int[] sort = new int[]{1,0,10,20,3,5,6,4,9,8,12,17,34,11};
public static void main(String[] args) {
    buildMaxHeapify(sort);
    heapSort(sort);
    print(sort);
}

private static void buildMaxHeapify(int[] data){
    //没有子节点的才需要创建最大堆，从最后一个的父节点开始
    int startIndex = getParentIndex(data.length - 1);
    //从尾端开始创建最大堆，每次都是正确的堆
    for (int i = startIndex; i &gt;= 0; i--) {
        maxHeapify(data, data.length, i);
    }
}

/**
 * 创建最大堆
 * @param data
 * @param heapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了
 * @param index当前需要创建最大堆的位置
 */
private static void maxHeapify(int[] data, int heapSize, int index){
    // 当前点与左右子节点比较
    int left = getChildLeftIndex(index);
    int right = getChildRightIndex(index);

    int largest = index;
    if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) {
        largest = left;
    }
    if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) {
        largest = right;
    }
    //得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整
    if (largest != index) {
        int temp = data[index];
        data[index] = data[largest];
        data[largest] = temp;
        maxHeapify(data, heapSize, largest);
    }
}

/**
 * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的
 * @param data
 */
private static void heapSort(int[] data) {
    //末尾与头交换，交换后调整最大堆
    for (int i = data.length - 1; i &gt; 0; i--) {
        int temp = data[0];
        data[0] = data[i];
        data[i] = temp;
        maxHeapify(data, i, 0);
    }
}

/**
 * 父节点位置
 * @param current
 * @return
 */
private static int getParentIndex(int current){
    return (current - 1) &gt;&gt; 1;
}

/**
 * 左子节点position注意括号，加法优先级更高
 * @param current
 * @return
 */
private static int getChildLeftIndex(int current){
    return (current &lt;&lt; 1) + 1;
}

/**
 * 右子节点position
 * @param current
 * @return
 */
private static int getChildRightIndex(int current){
    return (current &lt;&lt; 1) + 2;
}

private static void print(int[] data){
    int pre = -2;
    for (int i = 0; i &lt; data.length; i++) {
        if (pre &lt; (int)getLog(i+1)) {
            pre = (int)getLog(i+1);
            System.out.println();
        } 
        System.out.print(data[i] + &quot; |&quot;);
    }
}

/**
 * 以2为底的对数
 * @param param
 * @return
 */
private static double getLog(double param){
    return Math.log(param)/Math.log(2);
}
</code></pre><p>}</p>
<p>##归并排序<br>下面图片和代码来自维基百科</p>
<p><img src="http://i.imgur.com/IdjmrEz.gif" alt=""></p>
<pre><code>public int[] Two_Way_Merge_Sort(int[] A, int[] B) {
    int[] C = new int[A.length + B.length];
    int k = 0;
    int i = 0;
    int j = 0;
    while(i &lt; A.length &amp;&amp; j &lt; B.length) {
        if (A[i] &lt; B[j])
            C[k++] = A[i++];
        else
            C[k++] = B[j++];
    }
    while (i &lt; A.length) 
        C[k++] = A[i++];
    while (j &lt; B.length) 
        C[k++] = B[j++];
    return C;
}

/**
 * one good implements. &lt;br /&gt;
 *
 * 
 */
public class Sort {

public static final int CUTOFF = 11;

/**
     * merge sort algorithm.
     * 
     * @param arr an array of Comparable item.
 * 1.here only use one temp array (think about it). &lt;br /&gt;
 * 2.copy the element back after the sub merge operation. @see merge(T, T, int, int);
 * the above two points make it more efficient. &lt;br /&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort( T[] arr ) {
//you may use insertionSort instead when the arr.length is not that large.
        /*if ( arr.length &lt; CUTOFF ) {
            insertionSort( arr );
            return;
        }*/

        T[] tmpArr = (T[]) new Comparable[arr.length];

        mergeSort(arr, tmpArr, 0, arr.length - 1);
    }

    /**
     * internal method to make a recursive call to merge. &lt;br /&gt;
     * 
     * @param arr an array of Comparable items. &lt;br /&gt;
     * @param tmpArr temp array to placed the merged result. &lt;br /&gt;
     * @param left left-most index of the subarray. &lt;br /&gt;
     * @param right right-most index of the subarray. &lt;br /&gt;
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; 
    void mergeSort( T[] arr, T[] tmpArr,
            int left, int right ) {
        //recursive way
        if ( left &lt; right ) {
            int center = ( left + right ) / 2;
            mergeSort(arr, tmpArr, left, center);
            mergeSort(arr, tmpArr, center + 1, right);
            merge(arr, tmpArr, left, center + 1, right);
        }

        //loop instead，not working, do it youself.
/*
int n = 0, j;
        while ( true ) {
            int step = ( int ) Math.pow(2, ++n);
            int len = step / 2;
            int count = arr.length / step;
            int rpos;

            //previous pow(2, k) elements
            for ( j = 0; j &lt; count; j++ ) {
                rpos = j + len;
                System.out.println(j+&quot;, &quot;+rpos);
                merge( arr, tmpArr, j, rpos, rpos + len - 1);
            }

            //the rest elements
            //for () ;

            if ( step * 2 &gt;= arr.length ) break; 
        }
 */
    } 

    /**
     * internal method to merge the sorted halves of a subarray. &lt;br /&gt;
     * 
     * @param arr an array of Comparable items. &lt;br /&gt;
     * @param tmpArr temp array to placed the merged result. &lt;br /&gt;
     * @param leftPos left-most index of the subarray. &lt;br /&gt;
     * @param rightPos right start index of the subarray. &lt;br /&gt;
     * @param endPos right-most index of the subarray. &lt;br /&gt;
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge( T[] arr, T[] tmpArr,
            int lPos, int rPos, int rEnd ) {
        int lEnd = rPos - 1;
        int tPos = lPos;
        int leftTmp = lPos;

        while ( lPos &lt;= lEnd &amp;&amp; rPos &lt;= rEnd  ) {
            if ( arr[lPos].compareTo( arr[rPos] ) &lt;= 0 )
                tmpArr[ tPos++ ] = arr[ lPos++ ];
            else 
                tmpArr[ tPos++ ] = arr[ rPos++ ];
        }

        //copy the rest element of the left half subarray.
        while ( lPos &lt;= lEnd ) 
            tmpArr[ tPos++ ] = arr[ lPos++ ];
        //copy the rest elements of the right half subarray. (only one loop will be execute)
        while ( rPos &lt;= rEnd ) 
            tmpArr[ tPos++ ] = arr[ rPos++ ];

        //copy the tmpArr back cause we need to change the arr array items.
        for ( ; rEnd &gt;= leftTmp; rEnd-- )
            arr[rEnd] = tmpArr[rEnd];
    }
}
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/23/2018-03-23-Eclipse-NDK迁移到Android-Studio/" rel="next" title="Eclipse NDK迁移到Android Studio">
                <i class="fa fa-chevron-left"></i> Eclipse NDK迁移到Android Studio
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/25/2018-03-25-咖啡/" rel="prev" title="咖啡">
                咖啡 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Labradors</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图"><span class="nav-number">1.</span> <span class="nav-text">排序从数据结构上讲分为插入排序，交换排序，选择排序，归并排序，如下图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-number">1.1.</span> <span class="nav-text">插入排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">2.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">4.</span> <span class="nav-text">堆排序</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Labradors</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
